# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.28.0
# source: event.sql
from typing import Any, AsyncIterator, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from db import models


CREATE_EVENT = """-- name: create_event \\:one
INSERT INTO event (payload)
VALUES (:p1)
RETURNING id, uuid, created_at, payload
"""


GET_EVENT = """-- name: get_event \\:one
SELECT id, uuid, created_at, payload
FROM event
WHERE id = :p1
LIMIT 1
"""


LIST_EVENTS = """-- name: list_events \\:many
SELECT id, uuid, created_at, payload
FROM event
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_event(self, *, payload: Any) -> Optional[models.Event]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_EVENT), {"p1": payload})).first()
        if row is None:
            return None
        return models.Event(
            id=row[0],
            uuid=row[1],
            created_at=row[2],
            payload=row[3],
        )

    async def get_event(self, *, id: int) -> Optional[models.Event]:
        row = (await self._conn.execute(sqlalchemy.text(GET_EVENT), {"p1": id})).first()
        if row is None:
            return None
        return models.Event(
            id=row[0],
            uuid=row[1],
            created_at=row[2],
            payload=row[3],
        )

    async def list_events(self) -> AsyncIterator[models.Event]:
        result = await self._conn.stream(sqlalchemy.text(LIST_EVENTS))
        async for row in result:
            yield models.Event(
                id=row[0],
                uuid=row[1],
                created_at=row[2],
                payload=row[3],
            )
